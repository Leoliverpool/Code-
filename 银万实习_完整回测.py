import pandas as pdimport numpy as npimport mathimport matplotlib.pyplot as plt# %%0. 函数# 定义 EMA 和 XMA 函数# %%0.1 EMA函数def EMA(series, N):    ema = []  # 用于存储EMA值的列表    multiplier = 2 / (N + 1)  # 计算EMA的乘数因子    valid_series = series.dropna()  # 去除数据中的缺失值    # 确保初始的EMA是前N天的简单平均，确保包含N个非缺失值    initial_index = valid_series.index[N-1] if len(valid_series) >= N else None    if initial_index:        # 计算初始的EMA，使用前N天的简单平均        ema_initial = valid_series[:N].mean()        # 在结果列表中填充NaN值直到初始EMA位置        ema = [np.nan] * (series.index.get_loc(initial_index) ) + [ema_initial]                # 从天开始计算EMA        for price in valid_series[N:]:            # 根据公式计算EMA            ema.append((price - ema[-1]) * multiplier + ema[-1])    else:        # 如果有效数据不足N个，结果全为NaN        ema = [np.nan] * len(series)    # 返回一个与输入series具有相同索引的pd.Series    return pd.Series(ema, index=series.index)# %%0.2 新XMA函数 （用于计算某一特定日期下的XMA）def XMA1(series, N):    result = []    half_window = N // 2 + 1 if N % 2 == 0 else math.floor(N / 2) + 1    predictnumber = N // 2 - 1 if N % 2 == 0 else math.floor(N / 2)            for i in range(len(series) - half_window, len(series)):        past_data = series[ i-half_window+1:i+1].tolist()        future_data = []                for j in range(predictnumber):            if i + j + 1 < len(series):                future_data.append(series[i + j + 1])                  past_data.append(series[i + j + 1])                            else:                future_value = np.mean(past_data[j:])                future_data.append(future_value)                past_data.append(future_value)                            past_data = series[i-half_window+1:i+1].tolist()        full_window_data = past_data + future_data           xma_value = np.mean(full_window_data)        result.append(xma_value)        return result# %%0.3 新XMA函数 （用于计算某一特定日期下的XMA）def XMA2(series, N):    predictnumber = N // 2 - 1 if N % 2 == 0 else math.floor(N / 2)    past_data = series        for j in range(predictnumber):        future_value = np.mean(past_data[j:])        past_data.append(future_value)                        xma_value = np.mean(past_data)    result1 = xma_value            return result1# %%1. 读取数据 data = pd.read_excel('/Users/leoliverpool/Desktop/银万实习/已前复权_1min_所有数据.xlsx')data.set_index('date', inplace=True)# %%2. 计算白线上（ZK1）与白线下（ZD1）zk1_list = []zd1_list = []for i in range(24):    zk1_list.append(np.nan)    zd1_list.append(np.nan)for current_date in data.index: #每循环一次，计算一天的ZK1与ZD1    temp_data = data.loc[:current_date].copy()  #加.copy()是为了让temp_data不随data变动而变动 # 注意: .loc[:current_date]可以取到current_date，见本节末尾    if len(temp_data) >= 25:        XMA_XMA_high_25 = XMA2(XMA1(temp_data['high'], 25), 25)        XMA_XMA_low_25 = XMA2(XMA1(temp_data['low'], 25), 25)                ZK1 = (XMA_XMA_high_25 - XMA_XMA_low_25) * 1 + XMA_XMA_high_25        ZD1 = XMA_XMA_low_25 - (XMA_XMA_high_25 - XMA_XMA_low_25) * 1                zk1_list.append(ZK1)        zd1_list.append(ZD1)   # 创建Serieszk1_series = pd.Series(zk1_list, name='zk1')zd1_series = pd.Series(zd1_list, name='zd1')zk1_series.index = data.indexzd1_series.index = data.index# 将两个Series放进DataFramedata['zk1'] = zk1_seriesdata['zd1'] = zd1_series#data.to_excel('/Users/leoliverpool/Desktop/银万实习/已前复权_1min_所有数据_包含zk1与zd1.xlsx', index=True)# %%3. 回测# %%3.0 导入数据import numpy as npimport matplotlib.pyplot as pltimport pandas as pdimport yfinance as yfplt.rcParams['figure.figsize'] = (20,10)  # 设置图表的大小plt.style.use('fivethirtyeight')  # 使用 'fivethirtyeight' 风格from matplotlib import gridspec  # 用于创建网格布局from math import floor  # 导入 floor 函数，用于向下取整from matplotlib import pyplot as pltdata = pd.read_excel('/Users/leoliverpool/Desktop/银万实习/已前复权_1min_所有数据_包含zk1与zd1.xlsx')#data = pd.read_excel('/Users/leoliverpool/Desktop/银万实习/已前复权_1min_所有数据_包含所有.xlsx')data.set_index('date', inplace=True)data.index = pd.to_datetime(data.index)    # %%3.1 回测函数def get_whole_data1(data, startdate, enddate, transaction_ratio, index, logic):         #stockid # %%3.1.0 导入数据并初始化一些list    data = data[(data.index >= startdate) & (data.index < enddate)]    ISIN = data    data.rename(columns={        'zk1_diag': 'zk1',        'zd1_diag': 'zd1',        'open': 'Open',        'close': 'Close'    }, inplace=True)  #注意，data的变化也会影响ISIN，ISIN变量名变化        # 初始化用于存储信号、头寸、收益和最大回撤的列表    trade_signal = []    position = []    ret = []    cr = []    Max_Drawdown = []    Drawdown =[]    ret_close_minus_open = []    ret_open_minus_close = []    ultimate_return = []    ret_open_minus_open =[]        # %%3.1.1 生成signal    # 根据不同指标选择相应的策略    if index == 'MACD':        # 计算 MACD 指标的函数        def get_macd(close, fast, slow, compare):            DIF = close.ewm(span=fast, adjust=False).mean() - close.ewm(span=slow, adjust=False).mean()            DEA = DIF.ewm(span=compare, adjust=False).mean()            MACD = (DIF * DEA) * 2            return DIF, DEA, MACD            # 计算 DIF、DEA 和 MACD        DIF, DEA, MACD = get_macd(ISIN['Close'], 12, 26, 9)        ISIN['DIF'] = DIF  # 将计算结果添加到数据中        ISIN['DEA'] = DEA        ISIN['MACD'] = MACD            # MACD 策略        def strategy(prices, DIF, DEA, trade_signal):            signal = 0                for i in range(len(prices)):                # 买入信号条件                if DIF[i] > 0 and DEA[i] > 0 and DIF[i - 1] < DEA[i - 1] and DIF[i] > DEA[i]:                    if signal != 1:                        signal = 1                        trade_signal.append(signal)                    else:                        trade_signal.append(0)                # 卖出信号条件                elif DIF[i] < 0 and DEA[i] < 0 and DIF[i - 1] > DEA[i - 1] and DIF[i] < DEA[i]:                    if signal != -1:                        signal = -1                        trade_signal.append(signal)                    else:                        trade_signal.append(0)                else:                    trade_signal.append(0)                return trade_signal            trade_signal = strategy(ISIN['Close'], ISIN['DIF'], ISIN['DEA'], trade_signal)        elif index == 'ZS':        # 计算 ZS 指标的函数        def get_zs(close, nday):            mean = close.rolling(nday).mean()  # 计算均值            sd = close.rolling(nday).std()  # 计算标准差            zs = (close - mean) / sd  # 计算 Z 分数            return zs            ISIN['zs_14'] = get_zs(ISIN['Close'], 14)  # 计算 14 天的 ZS 指标            # ZS 策略        def strategy(prices, zs, trade_signal):            signal = 0                for i in range(len(prices)):                # 买入信号条件：Z 分数从低于 -2 上升到高于 -2                if zs[i - 1] < -2 and zs[i] > -2:                    if signal != 1:                        signal = 1                        trade_signal.append(signal)                    else:                        trade_signal.append(0)                # 卖出信号条件：Z 分数从高于 2 下降到低于 2                elif zs[i - 1] > 2 and zs[i] < 2:                    if signal != -1:                        signal = -1                        trade_signal.append(signal)                    else:                        trade_signal.append(0)                else:                    trade_signal.append(0)                return trade_signal            trade_signal = strategy(ISIN['Close'], ISIN['zs_14'], trade_signal)        elif index == 'WR':        # 计算 WR（威廉指标）的函数        def get_wr(high, low, close, nday):            highh = high.rolling(nday).max()  # 计算最高值            lowl = low.rolling(nday).min()  # 计算最低值            wr = -100 * ((highh - close) / (highh - lowl))  # 计算 WR 指标            return wr            ISIN['wr_14'] = get_wr(ISIN['High'], ISIN['Low'], ISIN['Close'], 14)  # 计算 14 天的 WR 指标            # WR 策略        def strategy(prices, wr, trade_signal):            signal = 0                for i in range(len(prices)):                # 买入信号条件：WR 从高于 -80 降到低于 -80                if wr[i - 1] > -80 and wr[i] < -80:                    if signal != 1:                        signal = 1                        trade_signal.append(signal)                    else:                        trade_signal.append(0)                # 卖出信号条件：WR 从低于 -20 上升到高于 -20                elif wr[i - 1] < -20 and wr[i] > -20:                    if signal != -1:                        signal = -1                        trade_signal.append(signal)                    else:                        trade_signal.append(0)                else:                    trade_signal.append(0)                return trade_signal            trade_signal = strategy(ISIN['Close'], ISIN['wr_14'], trade_signal)        elif index == 'BL':        # 计算布林带的函数        def get_bl(close, mday, nday, nstd):            UPP = close.rolling(mday).mean() + nstd * close.rolling(mday).std()  # 计算上轨              #注意：.rolling()即可应用于seires，又可应用于dataframe            #.rolling(20)意味着选中包括该观测值的最近20个观测值            DOWNP = close.rolling(nday).mean() - nstd * close.rolling(nday).std()  # 计算下轨            return UPP, DOWNP            UPP, DOWNP = get_bl(ISIN['Close'], 20, 14, 2)  # 计算 20 天的布林带        ISIN['bl_upp'] = UPP        ISIN['bl_downp'] = DOWNP            # 布林带策略        def strategy(prices, UPP, DOWNP, trade_signal):            signal = 0                for i in range(len(ISIN['Close']) ):                if i == 0:                    trade_signal.append(0)                # 买入信号条件：价格从下穿上轨到上穿上轨                else:                    if prices[i - 1] < UPP[i] and prices[i] > UPP[i]:                        if signal != 1:                            signal = 1                            trade_signal.append(signal)                        else:                            trade_signal.append(0)                # 卖出信号条件：价格从上穿下轨到下穿下轨                    elif prices[i - 1] > DOWNP[i] and prices[i] < DOWNP[i]:                        if signal != -1:                            signal = -1                            trade_signal.append(signal)                        else:                            trade_signal.append(0)                    else:                        trade_signal.append(0)                return trade_signal            trade_signal = strategy(ISIN['Close'], ISIN['bl_upp'], ISIN['bl_downp'], trade_signal)                elif index == 'XMA':        # 布林带策略        if logic == 'fanzhuan':                                    def strategy(prices, UPP, DOWNP, trade_signal):                signal = 0                        for i in range(len(ISIN['Close']) ):                    if i == 0:                        trade_signal.append(0)                    else:                        # 卖出信号条件                        if prices[i] > UPP[i]:                            if signal != -1:                                signal = -1                                trade_signal.append(signal)                            else:                                trade_signal.append(0)                        # 买入信号条件                        elif prices[i] < DOWNP[i]:                            if signal != 1:                                signal = 1                                trade_signal.append(signal)                            else:                                trade_signal.append(0)                        else:                            trade_signal.append(0)                        return trade_signal                    trade_signal = strategy(ISIN['Close'], ISIN['zk1'], ISIN['zd1'], trade_signal)                if logic == 'qushi':                                    def strategy(prices, UPP, DOWNP, trade_signal):                signal = 0                        for i in range(len(ISIN['Close']) ):                    if i == 0:                        trade_signal.append(0)                    else:                        # 买入信号条件                        if prices[i] > UPP[i]:                            if signal != 1:                                signal = 1                                trade_signal.append(signal)                            else:                                trade_signal.append(0)                        # 卖出信号条件                        elif prices[i] < DOWNP[i]:                            if signal != -1:                                signal = -1                                trade_signal.append(signal)                            else:                                trade_signal.append(0)                        else:                            trade_signal.append(0)                        return trade_signal                    trade_signal = strategy(ISIN['Close'], ISIN['zk1'], ISIN['zd1'], trade_signal)           trade_signal = pd.Series(trade_signal, index=ISIN.index)# %%3.1.1.1修改signal# %%3.1.1.1.1  将 9:30 至 9:55 之间的 signal 置为 0# 假设 ISIN 的 index 是 datetime 类型# 使用布尔索引筛选出每天 9:30 - 9:55 的数据    mask = (ISIN.index.time >= pd.Timestamp('09:30').time()) & (ISIN.index.time <= pd.Timestamp('09:55').time()) #一串array    #注意：布尔索引为list/series/array时，该语句 trade_signal[mask] = 0  均成立                #ISIN.index  #DatetimeIndex数据类型，不能用做比较    #ISIN.index.time #可以用做比较，一个包含很多datetime.time的array    #ISIN.index.date #可以用做比较，一个包含很多datetime.date的array    #A = pd.Timestamp('09:30') #timestamp数据类型的time，不能用做比较    #pd.Timestamp('09:30').time()    trade_signal[mask] = 0   #注意这里的trade_signal必须得是series，list不能用这种布尔索引的方法。（报错）                #F = pd.Series([1, 2, 3, 4, 5])    #mask11 = np.array([True, False, True, False, True])    #F[mask11] = 0    #print(F)    #G = [1, 2, 3, 4, 5]    #G[mask11] = 0  # 这将导致 TypeError# %%3.1.1.1.2   14:00 到 15:00 部分（保留每天的第一个信号，后面的设为 0）# 筛选出每天 14:00 到 15:00 的数据    mask_14_15 = (ISIN.index.time >= pd.Timestamp('14:00').time()) & (ISIN.index.time <= pd.Timestamp('15:00').time())# 提取出符合条件的信号    signal_14_15 = trade_signal[mask_14_15]#因此，原series + 布尔索引 等价于选中部分观测值    def keep_first_non_zero(group):        first_non_zero_found = False        for i in range(len(group)):            if not first_non_zero_found and group.iloc[i] != 0:                first_non_zero_found = True            elif first_non_zero_found:                group.iloc[i] = 0        return group# 按日期对 14:00 至 15:00 的信号进行分组，并应用函数    signal_14_15_grouped = signal_14_15.groupby(signal_14_15.index.date).apply(keep_first_non_zero)    # 新的index会在原index的左边    signal_14_15_grouped.index = signal_14_15_grouped.index.get_level_values(1)      # 提取第二层索引    signal_14_15_grouped.index = pd.to_datetime(signal_14_15_grouped.index)    #重要步骤    # 将修改后的数据更新回原始的 trade_signal_series    trade_signal.update(signal_14_15_grouped)    #注意：显然update的条件是内外series的index一致    trade_signal = trade_signal.tolist()    trade_signal = pd.Series(trade_signal, index=ISIN.index)    # %%3.1.2 生成position    # 根据交易信号计算头寸，1 表示多头，-1 表示空头        #先默认position全为1（为了把所有位置填满，确定列表大小）    for i in range(len(trade_signal)):        if trade_signal[i] > 1:            position.append(0)        else:            position.append(1)        #默认初始空仓    position[0] = 0            #注意：1. position=1 表示当天期末持有，并不一定代表当天期初持有；     #     2. trade_signal[i]决定i+1的position，因此最后一天的trade_signal用不到    for i in range(0, len(ISIN['Close'])-1):        if trade_signal[i] == 1:            position[i+1] = 1        elif trade_signal[i] == -1:            position[i+1] = -1        else:            position[i + 1] = position[i]                merged_df = pd.DataFrame({    'position': position,    'trade_signal': trade_signal })# %%3.1.2.1 修改 position# position的主要问题在于：每天14:00的第一个（每天最后一个）信号后，持仓仍不为0，且一直延续到第二天第一个trade_signal。这显然不符合逻辑。# 因此，要将每天14:00的第一个（每天最后一个）信号后的一分钟开始，直到第二天第一个trade_signal发生的那个分钟结束，将持仓设置为0。# %%3.1.2.1.1 找到每天14:00后第一个非零的trade_signal 的索引    # 确保 'merged_df' 的索引是日期时间格式    merged_df.index = pd.to_datetime(merged_df.index)        # 1. 创建一个布尔掩码，筛选出每天14:00之后的数据    mask_after_14 = merged_df.index.time >= pd.Timestamp('14:00').time() #可以看见，mask_after_14与前面的mask_14_15相等        # 2. 找到每天14:00后第一个非零的trade_signal    def get_first_non_zero_trade_signal_after_14(group):        non_zero_indices = group[group['trade_signal'] != 0].index        if len(non_zero_indices) > 0:            return non_zero_indices[0]  # 返回第一个非零的索引        return None            first_non_zero_after_14 = merged_df[mask_after_14].groupby(merged_df[mask_after_14].index.date).apply(get_first_non_zero_trade_signal_after_14)    #G = first_non_zero_after_14.index #G此时不是时间索引    first_non_zero_after_14.index = pd.to_datetime(first_non_zero_after_14.index)    #H =first_non_zero_after_14.index    #G == H    #二者数据类型不同    print(first_non_zero_after_14.dtype)          #注意：groupby与apply经常连用    #同时，groupby之前的df的index需要与后面的index长度一致     #（即使后面的index是可行的，但长度也必须相等（比如在上面，groupby(merged_df.index.date)便会出错））    #同时，一般groupby都会接前面的dataframe    #同时，最后会返回一个series（原数据类型）    #注意：first_non_zero_after_14的数据类型是datetime64[ns]，在这样一个序列中缺失值None被显示为NAT。        # %%3.1.2.1.2 找到每天的第一个非零 trade_signal 的索引    def get_first_non_zero_trade_signal(group):        non_zero_indices = group[group['trade_signal'] != 0].index        if len(non_zero_indices) > 0:            return non_zero_indices[0]  # 返回第一个非零的索引        return None        # 2. 按天分组，找到每一天的第一个非零 trade_signal    first_non_zero_per_day = merged_df.groupby(merged_df.index.date).apply(get_first_non_zero_trade_signal)            first_non_zero_per_day.index = pd.to_datetime(first_non_zero_per_day.index)        first_non_zero_after_14[0] +pd.Timedelta(minutes=1)    A = first_non_zero_after_14[0]        # %%3.1.2.1.3 将position的上述问题进行修改    first_non_zero_after_14.info()    first_non_zero_per_day.info()    for i in range(len(first_non_zero_after_14) - 1):        if pd.notna(first_non_zero_after_14[i]) & pd.notna(first_non_zero_per_day[i+1]):            # 将从当前第一个非零trade_signal的下一分钟到第二天第一个非零trade_signal的前一行的position设为0            start_idx = first_non_zero_after_14[i] + pd.Timedelta(minutes=1)            end_idx = first_non_zero_per_day[i+1]            if start_idx.time() != pd.Timestamp('15:01').time():                 merged_df.loc[start_idx:end_idx, 'position'] = 0                  #注意：.loc 会改变merged_df本身    #注意：.loc[start_idx:end_idx, 'position'] 会改变会取到start_idx和end_idx本身    #注意：虽然，first_non_zero_after_14里面部分日期显示的是NAT，但实际上是None，因此会跳过上述循环，符合逻辑与原本想法    #注意； first_non_zero_after_14[i] is not None不能排除掉NaT，只能使用pd.notna(first_non_zero_after_14[i])    #注意：需要考虑信号在最后一分钟（15:00）出现的情况，此时上述的代码若不加最后一个if，则会出错。因为merged_df中找不到15:01的index        # 最后一个非零的trade_signal，处理到当天最后    if pd.notna(first_non_zero_after_14[i]):        start_idx = first_non_zero_after_14[-1] + pd.Timedelta(minutes=1)        if start_idx.time() != pd.Timestamp('15:01').time():            merged_df.loc[start_idx:, 'position'] = 0        print(merged_df)            trade_signal = merged_df['trade_signal'].tolist()# 将 position 列转换为 list    position = merged_df['position'].tolist()    # %%3.1.3 生成ultimate_return（最终用于累计收益率计算的return，考虑了forward-looking bias以及交易费用）    # 计算每一天的从昨天收盘持有到今天收盘的收益率 （大部分使用这个收益率）    for i in range(len(ISIN['Close'])):        if i ==0:            ret.append(0)        else:             returns = (ISIN['Close'][i] - ISIN['Close'][i - 1]) / ISIN['Close'][i - 1]            ret.append(returns)                # 计算每一天的从开盘买入到当天收盘时的收益率 （为了应对trade_signal 为 1 的后一天的收益率）    for i in range(len(ISIN['Close'])):        returns = (ISIN['Close'][i] - ISIN['Open'][i]) / ISIN['Open'][i]        ret_close_minus_open.append(returns)            # 计算每一天的从昨天收盘持有到明天开盘时的收益率（为了应对trade_signal 为 -1 的当天的收益率）    for i in range(len(ISIN['Close']) - 1):        if i ==0:            ret_open_minus_close.append(0)        else:             returns = (ISIN['Open'][i + 1] - ISIN['Close'][i - 1]) / ISIN['Close'][i - 1]            ret_open_minus_close.append(returns)    ret_open_minus_close.append(0) #补足最后一个returns(由于没有后一天的open，因此无法算出)                #然而，以上的ultimate_return不足以完全准确描述连续两天出现 1、-1 时应当使用的收益率（1，0，-1 ；-1，0，1 ；-1，1）均可以描述。    #另一方面，1，-1连续两天出现理论上是有可能的(2024.8.5 日经)，只要求标的暴涨或暴跌即可（因为信号的出现取决于一天能够灵活变动的收盘价与不太敏感的上下限的大小对比）    #因此，想要得到准确的信号，需要额外考虑以上情况（利用类似于上述的方法）    for i in range(len(ISIN['Close'])):        if i ==0:            ret_open_minus_open.append(0)        else:             returns = (ISIN['Open'][i] - ISIN['Open'][i - 1]) / ISIN['Open'][i - 1]            ret_open_minus_open.append(returns)                        # 首先，确保 'trade_signal' 列存在于 merged_df 中    # 创建一个布尔列，判断 trade_signal 是否为非零    #non_zero = merged_df['trade_signal'] != 0        # 使用 shift() 检查当前和前一个索引的 trade_signal 是否连续为非零    #consecutive_non_zero = non_zero & non_zero.shift(1)        # 统计连续为非零的次数（True 的数量）    #consecutive_count = consecutive_non_zero.sum()        #print(f"连续两个index trade_signal非零的次数: {consecutive_count}") #0次                                #计算最终使用的return    ultimate_return = ret    for i in range(0, len(ISIN['Close']) - 1): #最后一个trade_signal不用        if i == 0:            1==1        else:            if trade_signal[i] == 1 and trade_signal[i+1] != -1 and trade_signal[i-1] != -1: #出现信号1且周围没有-1                ultimate_return[i] = ret_open_minus_close[i]                ultimate_return[i + 1] = ret_close_minus_open[i+1]                            elif trade_signal[i] == -1 and trade_signal[i+1] != 1 and trade_signal[i-1] != 1: #出现信号1且周围没有1                ultimate_return[i] = ret_open_minus_close[i]                ultimate_return[i + 1] = ret_close_minus_open[i+1]                                    elif trade_signal[i] == 1 and trade_signal[i+1] == -1:                ultimate_return[i] = ret_open_minus_close[i]                ultimate_return[i + 1] = ret_open_minus_open[i + 2]                ultimate_return[i + 2] = ret_close_minus_open[i + 2]                            elif trade_signal[i] == -1 and trade_signal[i+1] == 1:                ultimate_return[i] = ret_open_minus_close[i]                ultimate_return[i + 1] = ret_open_minus_open[i + 2]                ultimate_return[i + 2] = ret_close_minus_open[i + 2]                            else:                ultimate_return[i] = ultimate_return[i]                            #注意：不考虑1，-1，1 或 -1，1，-1 三个连续的情况。            #且由于第三第四种情况几乎不出现，因此直接循环至len(ISIN['Close']) - 1。理论上此时最后的ret_open_minus_open[i + 2]为            #ret_open_minus_open[len(ISIN['Close']，稍有问题。但忽略# %%3.1.3.1 修改ultimate_return#主要问题在于，（1）每天第一个trade_signal发生时，没有当分钟的平仓动作；（2）每天最后一个trade_signal发生时，没有下分钟的开仓动作#然而，由于这两个时刻持仓量都为0，因此实际上并不影响最后cr的计算。但为了严谨，修改。# %%3.1.3.1.1 修改每天最后一个trade_signal发生时，没有下分钟的开仓动作    ultimate_return = pd.Series(ultimate_return, index = ISIN.index)    merged_df['ultimate_return'] = ultimate_return        ret = pd.Series(ret, index = ISIN.index)            # 确保 first_non_zero_after_14 和 ret 的索引是时间格式    first_non_zero_after_14.index = pd.to_datetime(first_non_zero_after_14.index)    ret.index = pd.to_datetime(ret.index)            #注意：A = first_non_zero_after_14.dropna() 这样也可以把NaT去掉    # 遍历 first_non_zero_after_14 中的每个时间    for time in first_non_zero_after_14.dropna():  # dropna() 确保没有 None/NaT    #注意，for循环 in 接的可以是Series，默认遍历其中的每一个元素        # 获取当前时间的后一分钟时间点        next_minute = time + pd.Timedelta(minutes=1)        if next_minute.time() != pd.Timestamp('15:01').time():             merged_df.loc[next_minute, 'ultimate_return'] = ret.loc[time + pd.Timedelta(minutes=1)]    #注意：Series也可以使用loc    # %%3.1.3.1.2 修改每天第一个trade_signal发生时，没有当分钟的平仓动作    # 确保 first_non_zero_per_day 和 ret 的索引是时间格式    first_non_zero_per_day.index = pd.to_datetime(first_non_zero_per_day.index)    ret.index = pd.to_datetime(ret.index)        # 遍历 first_non_zero_per_day 中的每个时间    for time in first_non_zero_per_day.dropna():  # dropna() 确保没有 None/NaT        merged_df.loc[time, 'ultimate_return'] = ret.loc[time]        ultimate_return = merged_df['ultimate_return'].tolist()    ret = ret.tolist()# %%3.1.3.3 最终考虑交易费用与方向，算出 ultimate_return    #计算出策略使用到的最终的这个收益率（考虑多空方向）    for i in range(len(ISIN['Close'])):        ultimate_return[i] = position[i] * ultimate_return[i]                #考虑交易费用的最终return（在signal发生的当天与下一天，对return进行处理（假设交易费用为万分之一，且做多与做空均需手续费）    for i in range(len(ISIN['Close'])-1):        if trade_signal[i] == 1:            ultimate_return[i] = (1 + ultimate_return[i])* (1 - transaction_ratio) - 1            ultimate_return[i+1] = (1 + ultimate_return[i+1])* (1 - transaction_ratio) - 1        elif trade_signal[i] == -1:            ultimate_return[i] = (1 + ultimate_return[i])* (1 - transaction_ratio) - 1            ultimate_return[i+1] = (1 + ultimate_return[i+1])* (1 - transaction_ratio) - 1        else:            ultimate_return[i] = ultimate_return[i]                # %%3.1.4 生成cr    # 计算累计收益    for i in range(len(ISIN['Close'])):        if i == 0:            cumulative_returns = (1 + ultimate_return[i])             #有一点点问题，初始的信号第一次是1，则稍有误差（忽略）            cr.append(cumulative_returns)        else:            cumulative_returns = cr[i - 1] * (1 + ultimate_return[i])            cr.append(cumulative_returns)        # 调整累计收益，将其转换为 DataFrame    ISIN['cr']=cr        # %%3.1.4 生成 Max_Drawdown    # 计算最大回撤    for i in range(len(ISIN['Close'])):        Peak=ISIN['cr'].iloc[:i+1].max() #注意是从0取到i，i+1取不到        DD = (Peak-ISIN['cr'][i]) / Peak #ISIN['Close']也是一个series，可以使用[]来锁定元素        Drawdown.append(DD)            Drawdown= pd.DataFrame(Drawdown).rename(columns = {0:'Drawdown'}).set_index(ISIN.index)            for i in range(len(ISIN['Close'])):        MDD = Drawdown['Drawdown'].iloc[:i+1].max()        Max_Drawdown.append(MDD)        Max_Drawdown= pd.DataFrame(Max_Drawdown).rename(columns = {0:'Max_Drawdown'}).set_index(ISIN.index)            # %%3.1.5 将以上list/dataframe/series导入进ISIN（data）    position = pd.DataFrame(position).rename(columns = {0:'position'}).set_index(ISIN.index)    ISIN['position']=position        ISIN['Max_Drawdown']=Max_Drawdown    ISIN['trade_signal']=trade_signal    ISIN['ultimate_return'] = ultimate_return        cr = [value - 1 for value in cr]    cr = pd.DataFrame(cr).rename(columns={0: 'Cumulative Return'}).set_index(ISIN.index)    ISIN['cr']=cr                        # %%3.1.6 最后生成return_close，cr_close以及return_diff （假设长期多一股510300的收益率，累计收益率以及与上述策略的收益率差值）    ISIN['return_close'] = ISIN['Close'].pct_change()    ISIN['return_close'][0] = 0        ISIN['cr_close'] = (1 + ISIN['return_close']).cumprod() - 1        ISIN['return_diff'] = ISIN['ultimate_return'] - ISIN['return_close']                return data        The_final_data = get_whole_data1(data, '2024-01-01', '2024-09-01', 0.0001, 'XMA', 'fanzhuan')ISIN = The_final_data# %%3.2 继续回测（对整体统计）# %%3.2.1 统计每年策略收益率average_return_diff = ISIN['return_diff'].mean()data['year'] = data.index.yearISIN['cr']=ISIN['cr'] + 1# 使用groupby按年度分组annual_returns = data.groupby('year')['cr'].apply(lambda x: (x.iloc[-1] - x.iloc[0]) / x.iloc[0])# 结果显示print(annual_returns)# %%3.2.2 统计历史上每个月的策略收益率（所有年的所有月份）# 先将索引 'date' 转换为年月（即使用 PeriodIndex）data['month'] = data.index.to_period('M')# 使用 groupby 按月份分组，计算每个月的收益率monthly_returns = data.groupby('month')['cr'].apply(lambda x: (x.iloc[-1] - x.iloc[0]) / x.iloc[0])# 过滤出所有收益率大于 0 的月份positive_monthly_returns = monthly_returns[monthly_returns > 0]# 结果显示print(positive_monthly_returns)# %%3.2.3 统计不同月份的策略收益率（同一月份不同年的平均收益率）# 提取月份（忽略年份）monthly_returns.index = monthly_returns.index.strftime('%m')  # 将年份去掉，只保留月份# 按月份分组并计算每个月的平均收益率average_monthly_returns = monthly_returns.groupby(monthly_returns.index).mean()# 显示结果print(average_monthly_returns)# %%3.2.4 统计不同分钟的策略收益率（每一个分钟在过去历史上每一天的平均收益率）# 提取分钟信息（小时和分钟），忽略日期data['minute_only'] = data.index.strftime('%H:%M')# 按分钟分组，计算每一分钟的平均收益率average_minute_returns = data.groupby('minute_only')['ultimate_return'].mean()# 显示结果print(average_minute_returns)positive_average_minute_returns = average_minute_returns[average_minute_returns > 0]# %%3.2.5 统计18年12月的策略收益率情况# Filter the existing 'data' DataFrame to include only rows from December 2018filtered_data = data[(data.index >= '2018-12-01') & (data.index < '2019-01-01')]filtered_data['cr'][0] = 1 cr=[]for i in range(len(filtered_data)):    if i == 0:        cumulative_returns = 1        #有一点点问题，初始的信号第一次是1，则稍有误差（忽略）        cr.append(cumulative_returns)    else:        cumulative_returns = cr[i - 1] * (1 + filtered_data['ultimate_return'][i])        cr.append(cumulative_returns)# 调整累计收益，将其转换为 DataFramefiltered_data['cr']=cr# 调整累计收益，将其转换为 DataFramefiltered_data['cr'] = filtered_data['cr'] - 1#ISIN = filtered_data#data.to_excel('/Users/leoliverpool/Desktop/银万实习/已前复权_1min_所有数据_包含所有.xlsx', index=True)# %%4. 画图# 第四部分：绘制图形# 绘制图表# %%4.1 图1    def draw_four_pictures(ISIN):    import mplfinance as mpf    import pandas as pd        # Step 1: 为每个Series创建DataFrame并填充相同的OHLC数据    df_cr = ISIN['cr'].to_frame(name='Close')    df_cr['Open'] = df_cr['Close']    df_cr['High'] = df_cr['Close']    df_cr['Low'] = df_cr['Close']        df_drawdown = ISIN['Max_Drawdown'].to_frame(name='Close')    df_drawdown['Open'] = df_drawdown['Close']    df_drawdown['High'] = df_drawdown['Close']    df_drawdown['Low'] = df_drawdown['Close']        df_position = ISIN['position'].to_frame(name='Close')    df_position['Open'] = df_position['Close']    df_position['High'] = df_position['Close']    df_position['Low'] = df_position['Close']        df_trade_signal = ISIN['trade_signal'].to_frame(name='Close')    df_trade_signal['Open'] = df_trade_signal['Close']    df_trade_signal['High'] = df_trade_signal['Close']    df_trade_signal['Low'] = df_trade_signal['Close']        # Step 2: 使用mplfinance绘制图表    # 创建每个plot的对象    ap1 = [mpf.make_addplot(df_cr['Close'], panel=0, color='blue', ylabel='Profit Ratio')]    ap2 = [mpf.make_addplot(df_drawdown['Close'], panel=1, color='orange', ylabel='Max Drawdown')]    ap3 = [mpf.make_addplot(df_position['Close'], panel=2, type='bar', color='blue', ylabel='Position')]    ap4 = [mpf.make_addplot(df_trade_signal['Close'], panel=3, color='green', ylabel='Trade Signal')]        # 自定义风格    style = mpf.make_mpf_style(base_mpf_style='classic', gridstyle='-', facecolor='lightgray')        # 绘制多子图的图表    mpf.plot(df_cr, type='candle', style=style, addplot=ap1+ap2+ap3+ap4, figsize=(10,12), title="Financial Data",             panel_ratios=(2, 1, 1, 1), ylabel='Price', show_nontrading=False)                            # %%4.2 图2    import mplfinance as mpf    import pandas as pd        # Step 1: 为每个Series创建DataFrame并填充相同的OHLC数据    df_cr = ISIN['cr'].to_frame(name='Close')    df_cr['Open'] = df_cr['Close']    df_cr['High'] = df_cr['Close']    df_cr['Low'] = df_cr['Close']        df_cr_close = ISIN['cr_close'].to_frame(name='Close')    df_cr_close['Open'] = df_cr_close['Close']    df_cr_close['High'] = df_cr_close['Close']    df_cr_close['Low'] = df_cr_close['Close']        df_ultimate_return = ISIN['ultimate_return'].to_frame(name='Close')    df_ultimate_return['Open'] = df_ultimate_return['Close']    df_ultimate_return['High'] = df_ultimate_return['Close']    df_ultimate_return['Low'] = df_ultimate_return['Close']        df_return_close = ISIN['return_close'].to_frame(name='Close')    df_return_close['Open'] = df_return_close['Close']    df_return_close['High'] = df_return_close['Close']    df_return_close['Low'] = df_return_close['Close']        # Step 2: 使用 mplfinance 进行多子图绘制    # 创建每个plot的对象    ap1 = [mpf.make_addplot(df_cr['Close'], panel=0, color='blue', ylabel='Cumulative Return (cr)')]    ap2 = [mpf.make_addplot(df_cr_close['Close'], panel=1, color='green', ylabel='Cumulative Return (cr_close)')]    ap3 = [mpf.make_addplot(df_ultimate_return['Close'], panel=2, color='red', ylabel='Ultimate Return')]    ap4 = [mpf.make_addplot(df_return_close['Close'], panel=3, color='orange', ylabel='Return (Close)')]        # 定义图表风格    style = mpf.make_mpf_style(base_mpf_style='classic', gridstyle='-', facecolor='lightgray')        # 绘制多子图的图表    mpf.plot(df_cr, type='candle', style=style, addplot=ap1+ap2+ap3+ap4, figsize=(24,20), title="Financial Data",             panel_ratios=(1,1,1,1), ylabel='Price', show_nontrading=False)                # %%4.3 图3        import mplfinance as mpf    import pandas as pd        # Step 1: 将每个Series转换为符合mplfinance格式的DataFrame    df_cr = ISIN['cr'].to_frame(name='Close')    df_cr['Open'] = df_cr['Close']    df_cr['High'] = df_cr['Close']    df_cr['Low'] = df_cr['Close']        df_cr_close = ISIN['cr_close'].to_frame(name='Close')    df_cr_close['Open'] = df_cr_close['Close']    df_cr_close['High'] = df_cr_close['Close']    df_cr_close['Low'] = df_cr_close['Close']        df_trade_signal = ISIN['trade_signal'].to_frame(name='Close')    df_trade_signal['Open'] = df_trade_signal['Close']    df_trade_signal['High'] = df_trade_signal['Close']    df_trade_signal['Low'] = df_trade_signal['Close']        # Step 2: 使用mplfinance绘制图表    # 创建每个子图的plot对象    ap1 = [mpf.make_addplot(df_cr['Close'], panel=0, color='blue', ylabel='Cumulative Return (cr)')]    ap2 = [mpf.make_addplot(df_cr_close['Close'], panel=1, color='green', ylabel='Cumulative Return (cr_close)')]    ap3 = [mpf.make_addplot(df_trade_signal['Close'], panel=2, color='red', ylabel='Trade Signal')]        # 定义图表风格    style = mpf.make_mpf_style(base_mpf_style='classic', gridstyle='-', facecolor='lightgray')        # 绘制多子图的图表    mpf.plot(df_cr, type='candle', style=style, addplot=ap1+ap2+ap3, figsize=(12,10), title="Financial Data",             panel_ratios=(1, 1, 1), ylabel='Price', show_nontrading=False)                # %%4.4 图4            import mplfinance as mpf    import pandas as pd        # Step 1: 将每个Series转换为符合mplfinance格式的DataFrame    df_cr = ISIN['cr'].to_frame(name='Close')    df_cr['Open'] = df_cr['Close']    df_cr['High'] = df_cr['Close']    df_cr['Low'] = df_cr['Close']        df_cr_close = ISIN['cr_close'].to_frame(name='Close')    df_cr_close['Open'] = df_cr_close['Close']    df_cr_close['High'] = df_cr_close['Close']    df_cr_close['Low'] = df_cr_close['Close']        df_return_diff = ISIN['return_diff'].to_frame(name='Close')    df_return_diff['Open'] = df_return_diff['Close']    df_return_diff['High'] = df_return_diff['Close']    df_return_diff['Low'] = df_return_diff['Close']        df_trade_signal = ISIN['trade_signal'].to_frame(name='Close')    df_trade_signal['Open'] = df_trade_signal['Close']    df_trade_signal['High'] = df_trade_signal['Close']    df_trade_signal['Low'] = df_trade_signal['Close']        # Step 2: 使用mplfinance绘制图表    # 创建每个子图的plot对象    ap1 = [mpf.make_addplot(df_cr['Close'], panel=0, color='blue', ylabel='Cumulative Return (cr)')]    ap2 = [mpf.make_addplot(df_cr_close['Close'], panel=1, color='green', ylabel='Cumulative Return (cr_close)')]    ap3 = [mpf.make_addplot(df_return_diff['Close'], panel=2, color='orange', ylabel='Return Diff')]    ap4 = [mpf.make_addplot(df_trade_signal['Close'], panel=3, color='red', ylabel='Trade Signal')]        # 定义图表风格    style = mpf.make_mpf_style(base_mpf_style='classic', gridstyle='-', facecolor='lightgray')        # 绘制多子图的图表    mpf.plot(df_cr, type='candle', style=style, addplot=ap1+ap2+ap3+ap4, figsize=(12,10), title="Financial Data",             panel_ratios=(1, 1, 1, 1), ylabel='Price', show_nontrading=False)                        def draw_first_picture(ISIN):    import mplfinance as mpf    import pandas as pd        # Step 1: 为每个Series创建DataFrame并填充相同的OHLC数据    df_cr = ISIN['cr'].to_frame(name='Close')    df_cr['Open'] = df_cr['Close']    df_cr['High'] = df_cr['Close']    df_cr['Low'] = df_cr['Close']        df_drawdown = ISIN['Max_Drawdown'].to_frame(name='Close')    df_drawdown['Open'] = df_drawdown['Close']    df_drawdown['High'] = df_drawdown['Close']    df_drawdown['Low'] = df_drawdown['Close']        df_position = ISIN['position'].to_frame(name='Close')    df_position['Open'] = df_position['Close']    df_position['High'] = df_position['Close']    df_position['Low'] = df_position['Close']        df_trade_signal = ISIN['trade_signal'].to_frame(name='Close')    df_trade_signal['Open'] = df_trade_signal['Close']    df_trade_signal['High'] = df_trade_signal['Close']    df_trade_signal['Low'] = df_trade_signal['Close']        # Step 2: 使用mplfinance绘制图表    # 创建每个plot的对象    ap1 = [mpf.make_addplot(df_cr['Close'], panel=0, color='blue', ylabel='Profit Ratio')]    ap2 = [mpf.make_addplot(df_drawdown['Close'], panel=1, color='orange', ylabel='Max Drawdown')]    ap3 = [mpf.make_addplot(df_position['Close'], panel=2, type='bar', color='blue', ylabel='Position')]    ap4 = [mpf.make_addplot(df_trade_signal['Close'], panel=3, color='green', ylabel='Trade Signal')]        # 自定义风格    style = mpf.make_mpf_style(base_mpf_style='classic', gridstyle='-', facecolor='lightgray')        # 绘制多子图的图表    mpf.plot(df_cr, type='candle', style=style, addplot=ap1+ap2+ap3+ap4, figsize=(10,12), title="Financial Data",             panel_ratios=(2, 1, 1, 1), ylabel='Price', show_nontrading=False)        draw_first_picture(ISIN)draw_four_pictures(ISIN)    def draw_one_picture(ISIN):    import mplfinance as mpf    import pandas as pd    # Step 1: 为每个Series创建DataFrame并填充相同的OHLC数据    df_cr = ISIN['cr'].to_frame(name='Close')    df_cr['Open'] = df_cr['Close']    df_cr['High'] = df_cr['Close']    df_cr['Low'] = df_cr['Close']    df_drawdown = ISIN['Max_Drawdown'].to_frame(name='Close')    df_drawdown['Open'] = df_drawdown['Close']    df_drawdown['High'] = df_drawdown['Close']    df_drawdown['Low'] = df_drawdown['Close']    df_cr_close = ISIN['cr_close'].to_frame(name='Close')    df_cr_close['Open'] = df_cr_close['Close']    df_cr_close['High'] = df_cr_close['Close']    df_cr_close['Low'] = df_cr_close['Close']    # Step 2: 使用mplfinance绘制图表    # 创建每个子图的plot对象    ap1 = [mpf.make_addplot(df_cr['Close'], panel=0, color='blue', ylabel='Cumulative Return (cr)')]    ap2 = [mpf.make_addplot(df_drawdown['Close'], panel=1, color='orange', ylabel='Max Drawdown')]    ap3 = [mpf.make_addplot(df_cr_close['Close'], panel=2, color='green', ylabel='Cumulative Return (cr_close)')]    # 自定义风格    style = mpf.make_mpf_style(base_mpf_style='classic', gridstyle='-', facecolor='lightgray')    # 绘制多子图的图表，包含三个面板    mpf.plot(df_cr, type='candle', style=style, addplot=ap1+ap2+ap3, figsize=(10, 12), title="Financial Data",             panel_ratios=(2, 1, 1), ylabel='Price', show_nontrading=False)    draw_first_picture(ISIN)draw_four_pictures(ISIN)draw_one_picture(ISIN)index = 'XMA'logic = 'fanzhuan'startdate = '2024-01-01'enddate = '2024-09-01'data = data[(data.index >= startdate) & (data.index < enddate)]logic ='fanzhuan'ISIN = datatransaction_ratio = 0.0001