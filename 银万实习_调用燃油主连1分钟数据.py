#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Fri Sep 13 18:20:20 2024@author: leoliverpool"""# %%1 调取数据(仅包含两个月，手动调取)import tushare as tsimport pandas as pdfrom datetime import datetime, timedelta# 初始化Tushare Pro APIts.set_token('d4b369693ea0913b0702e78a33bbf9057130f5a7c58ee2777810045e')pro = ts.pro_api()df = pro.ft_mins(ts_code='FU2409.SHF', freq='1min', start_date='2024-07-01 09:00:00', end_date='2024-08-30 23:59:00')df1 = pro.ft_mins(ts_code='FU2409.SHF', freq='1min', start_date='2024-07-01 09:00:00', end_date='2024-07-30 14:18:00')df2 = pd.concat([df,df1], axis=0) #axis=0 代表按行拼接df3 = df2.iloc[::-1]#df4 = df3.reset_index() #此时index变成新的一个column，因此需要drop=Truedf4 = df3.reset_index(drop = True)df5 = df4.set_index('trade_time') #原index会消失df6 = df5.drop(['ts_code', 'vol', 'amount', 'oi'], axis=1) #drop函数df7= df2.iloc[::-1].reset_index(drop = True).set_index('trade_time').drop(['ts_code', 'vol', 'amount', 'oi'],axis=1)#在 Python 中，将多个方法或属性连用是一种链式调用（chaining）的思想，#这种方式非常符合 Python 语言的简洁和易读性，并且常用于数据处理和分析工作中。#二者完全相同data = df7data = get_zk1_zd1(data)The_final_data = get_whole_data(data, '2020-07-01', '2024-09-01', 0.0001, 'XMA', 'fanzhuan')ISIN = The_final_dataISIN.index = pd.to_datetime(ISIN.index)draw_one_picture(ISIN)# %%2 调取数据 (2020年至2024年10月31日)# %%2.1 调取原始数据 #df11 = df10.iloc[1,1] #需要注意第一列是0，第一行是也是0。同时，行列之间用，分隔。all_data = pd.DataFrame() #注意，这样子可以定义一个空的dataframedf10 = pro.fut_mapping(ts_code='FU.SHF') #用于寻找主力合约，进而构建主力连续合约的价格df10.info() #用于查看数据类型df10 = df10.iloc[::-1] #不要忘记用中括号，且这里无需逗号df10['trade_date'] = pd.to_datetime(df10['trade_date']) #可以直接转化（里面全是数字的字符串）len(df10)#df中也有len函数for i in range(len(df10)):    date = df10.iloc[i,1]    start_date = date.strftime('%Y-%m-%d')    end_date = (date + timedelta(days = 1)).strftime('%Y-%m-%d')     #注意days = 1 的用法    mapping_ts_code = df10.iloc[i,2]    df = pro.ft_mins(ts_code= mapping_ts_code, freq='1min', start_date= start_date, end_date=end_date)    df = df.iloc[::-1]    all_data = pd.concat([all_data, df], axis = 0) #注意加中括号    print(all_data)#all_data.to_excel('/Users/leoliverpool/Desktop/银万实习/期货数据/燃油主连.xlsx', index=True)# %%2.2 将数据限制于2020年后all_data.info()all_data = all_data.set_index('trade_time') #原index会消失all_data = all_data.drop([ 'vol', 'amount', 'oi'], axis=1) #drop函数all_data.info()all_data['open'] = pd.to_numeric(all_data['open'])all_data['close'] = pd.to_numeric(all_data['close'])all_data.info()all_data.tail()data = all_datazero_high_count = (data['high'] == 0).sum()zero_low_count = (data['low'] == 0).sum()zero_open_count = (data['open'] == 0).sum()zero_close_count = (data['close'] == 0).sum()zero_high_indices = data.index[data['high'] == 0].tolist()zero_low_indices = data.index[data['low'] == 0].tolist()zero_open_indices = data.index[data['open'] == 0].tolist()zero_close_indices = data.index[data['close'] == 0].tolist()na_open_indices = data.index[data['open'].isna()].tolist()na_open_count = len(na_open_indices)all_data.info()start_date = '2020-01-02' #20年才出现夜盘，19年交易开始活跃。（所以19年也可以）end_date = '2024-10-31'all_data_filtered = all_data[(all_data.index >= start_date) & (all_data.index <= end_date)]all_data_filtered#all_data_filtered = all_data.drop([ 'zk1', 'zd1'], axis=1) #drop函数all_data_filtered.info()# %%2.3 生成zk1和zd1data = get_zk1_zd1(all_data_filtered)data.info()#The_final_data.to_excel('/Users/leoliverpool/Desktop/银万实习/期货数据/燃油主连的所有数据(包括夜盘_zk1zd1_cr等_20年至24年).xlsx', index=True)# %%2.4 去掉夜盘#data = pd.read_excel('/Users/leoliverpool/Desktop/银万实习/期货数据/燃油主连的所有数据(包括夜盘_zk1zd1_cr等_20年至24年).xlsx')all_data_filtered.index = pd.to_datetime(all_data_filtered.index)start_time = pd.Timestamp('21:00').time()end_time = pd.Timestamp('23:00').time()data_filtered = all_data_filtered[~((all_data_filtered.index.time >= start_time) & (all_data_filtered.index.time <= end_time))]#The_final_data = get_whole_data(data, '2020-01-02', '2020-11-01', 0.0000, 'XMA', 'fanzhuan')#ISIN = The_final_data#ISIN.index = pd.to_datetime(ISIN.index)#draw_one_picture(ISIN)# 确保索引为日期时间格式，如果不是，可以先转换data_filtered = data.copy()data_filtered.index = pd.to_datetime(data_filtered.index, errors='coerce')# 删除索引为 3 月 6 日的行data_filtered = data_filtered[~((data_filtered.index.month == 3) & (data_filtered.index.day == 6))]# 确保索引为日期时间格式data_filtered.index = pd.to_datetime(data_filtered.index, errors='coerce')# 删除所有索引在 2022 年 3 月 7 日的数据data_filtered1 = data_filtered[~((data_filtered.index.date == pd.to_datetime('2022-03-07').date()))]# %%2.5 开始回测#data = ISIN.copy().drop(['cr','ultimate_return','Max_Drawdown','trade_signal','position','return_close','cr_close','return_diff'],axis = 1)#data.info()The_final_data1 = get_whole_data1(data_filtered1, '2020-01-02', '2024-10-31', 0.0001, 'XMA', 'fanzhuan')ISIN = The_final_data1ISIN.index = pd.to_datetime(ISIN.index)draw_one_picture(ISIN)#The_final_data1.to_excel('/Users/leoliverpool/Desktop/银万实习/期货数据/燃油主连的数据(不包括夜盘_不包含交易费用_不包括价格不变的两天_包含zk1zd1_cr等_20年至24年).xlsx', index=True)# 按天分组，检查每一天的 close 列是否都相同same_close_days = ISIN.groupby(ISIN.index.date)['Close'].apply(lambda x: x.nunique() == 1)# 提取所有 close 值相同的日期result_dates = same_close_days[same_close_days].indexprint("所有 close 值相同的日期：")print(result_dates)